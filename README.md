# lab1
- [link](http://web.eecs.umich.edu/~sugih/courses/eecs489/lab1.html)
##
- 服务端提供图像
- 客户端显示图像


## EECS 489实验1：远程图像显示
- 该作业的截止日期为2016年1月15日（星期五）下午6点。
tl; dr
由于这是我们涉及编程的第一个任务，因此此描述有点长。请仔细阅读整个内容，以设置本课程中的实验和编程任务的工作方式：如何访问支持代码，如何设置命令行选项，如何测试代码，预期上交的内容（ （而不是上交），以及如何提交您的代码，其余的内容在很大程度上保持不变。
介绍
- 本实验是套接字编程的复习。我假设您在本课程之前已经做过一些套接字编程，无论是作为EECS 482中的项目还是具有同等经验的人。我进一步假设您知道如何在所选的开发环境上构建套接字程序，如Lab 0所述。如果您的套接字编程技巧生锈或不稳定，或者您仍然不确定如何使用自己喜欢的构建工具来构建套接字程序，那么本练习将为您提供同时支持这两种方法的机会。在完成此实验时，您可以参考实验0中的示例代码server.c 和client.c。
- 在本实验中，我们将构建一个简单的客户端-服务器远程图像查看器。完成后，服务器将向客户端提供图像，然后客户端使用OpenGL显示该图像。该实验室应为您提供有关其适用性的直接反馈：正确完成的项目将在客户端上显示可识别的图像。未完成或编写不正确的项目可能不会。在整个学期中，我们将使用此远程图像显示工具来帮助您可视化各种网络协议的效果。可视化工具还可以帮助您检测代码中的一些错误。

- 您将获得包含以下内容的基本代码：
-  客户端netimg.cpp和netimglut.cpp，netimg imgdb.cpp和imgdb.h服务器，imgdb，
通用头文件netimg.h，
- 一个通用的套接字包装库socks.cpp和socks.h，以及
- 服务器refimgdb的参考Linux二进制可执行文件。
- 您应该能够在提供的服务器上运行客户端。提供的Makefile构建imgdb和netimg。您可以从“课程文件夹” 下载 支持代码。
- 您可以在代码中搜索字符串“ YOUR CODE HERE”，以查找代码必须去的地方。但是，您需要阅读源文件中的所有注释。在注释中有关于功能的预期行为的信息，以及有关使用的结构和变量的假设，这些信息不一定在本规范文档中阐明。在编写第一行代码之前，您可能还希望一直阅读本规范文档。例如，您可能会发现有关如何测试代码的部分很有用。
### 任务1：客户端
- 您的第一个任务是编写客户端代码。客户端采用一个必需的命令行参数：
```
% netimg -s <server>:<port> -q <image>.tga [-v <version>]
```
- 其中'％'表示不键入的Unix C-shell提示符（如果使用bash，则提示符可能是'$“而不是'％'）。- s选项告诉netimg哪个服务器除非已将DNS解析程序设置为搜索服务器的域（如本教程中所示），否则，您必须提供服务器的标准域名（FQDN）或IP地址以及端口号服务器正在侦听，并用冒号分隔。尖括号（“ <>”）表示您将提供所需参数的实际值。运行程序时，请勿自行输入尖括号。样本测试用例的测试部分。

该-q选项告诉netimg程序来查询服务器，其图像文件。用您的TGA图像文件的名称替换“ <image> ”，同样，您也不必输入尖括号。该文件必须是TGA图像文件。提供了两个示例TGA图像文件供您使用。您可以使用Apple的Preview，GIMP，Photoshop或其他图像查看工具来查看它们。如果要使用JPEG或PNG或其他图像格式，则需要先将它们转换为TGA文件。例如，作为在Linux和Mac OS X上运行的ImageMagick程序包的一部分的图形工具 convert可以执行此转换。如果您的图像颠倒显示，convert也可以为您翻转图像。

该-v选项允许你改变的版本号 iqry包发送。您应该使用它来测试服务器功能imgdb :: recvqry（）是否正在正确检查所有传入的iqry数据包的版本字段。上面的命令行规范中的方括号“ []”表示第二个参数是可选的，在运行程序时不要输入方括号。

您可以在socks.cpp和 netimg.cpp中搜索字符串“ Task 1”，以查找必须填写与“ Task 1”相关的代码的位置。函数socks_clntinit（server，sname，复用，self） 连接到服务器，要么在服务器参数的sin_addr字段中指定的IPv4地址上 ，要么，如果 sin_addr字段为0，则在sname参数指定的主机名上 。必须指定IPv4地址或主机名之一。在这两种情况下，sin_port中的 服务器参数必须是有效的，并且必须包含服务器的端口号。这是一个非常简单的任务，与其中的代码没有太大不同实验0的client.c。首先创建一个新的TCP套接字。设置套接字选项，以使套接字在关闭时会停留NETIMG_LINGER时间，以留出时间让未完成的数据到达目标。如果未提供服务器的IPv4地址，请从服务器名称中获取其地址，该名称必须在sname中提供。接下来，使用服务器的IPv4地址和端口号初始化套接字。最后连接到服务器，并将连接的套接字描述符返回给调用方。如果对connect（）的调用失败，请关闭新创建的套接字并返回SOCKS_UNINIT_SD。对于其他任何错误，请终止该过程。该socks_clntinit（）已对函数进行了注释，以便应清楚在何处进行哪个套接字API调用。该函数的第三个参数，重用在实验2中使用，第四个参数self在PA1中使用，您现在可以忽略它们。根据您执行的错误检查数量，此部分实验应使用大约16到20行代码。如果使用Windows，则用于关闭套接字的API称为 closesocket（）而不是close（）。所提供的 socks_close（）包装函数可以进行适合系统的调用以关闭套接字。

接下来，编写netimg_recvimsg（）函数以接收来自服务器的返回数据包。返回数据包必须为imsg_t数据类型 。将数据包存储在全局变量imsg中。此处显示的结构imsg_t在netimg.h中定义 。


它存储图像的详细信息：宽度，高度等，我们将需要显示它们。您必须检查传入数据包的版本号。如果不是 NETIMG_VERS，则必须返回NETIMG_EVERS（均在netimg.h中定义）。（将测试您的编程分配以检查数据包版本号，因此现在就养成检查它的习惯。）此功能大约需要9行代码。

最后，您要在netimg_recvimg（）中编写3至5行代码， 以接收图像文件本身。您将使用全局变量img_size和img_offset 完成此任务。

任务1就是这样。您将总共编写约28到33行代码。完成任务1后，您应该先测试代码，然后再继续执行任务2。有关使用服务器的参考实现测试代码的一些指导，请参阅下面的“测试”部分。

- 您将注意到，我们使用OpenGL / GLUT来显示从服务器接收的图像。不用说，您不需要了解OpenGL。您所有的代码仅涉及网络编程。不过，您需要知道如何构建OpenGL / GLUT程序。如果使用提供的Makefile生成程序，则只需键入make（在Linux和Windows系统上，首次生成OpenGL / GLUT程序时，可能需要先安装GLUT）。如果要使用IDE进行构建，则需要将文件netimg.cpp，netimglut.cpp，socks.cpp， socks.h和netimg.h添加到项目中（以及 wingetopt.h和如果您使用的是Windows，则为wingetopt.c。不要添加其他文件。然后，您需要告诉IDE您要与OpenGL库链接。如果您不知道如何安装GLUT或如何与OpenGL库链接，请按照EECS 487课程注释“ 构建OpenGL / GLUT程序”中的说明进行操作。如果您对OpenGL代码感到好奇，请随时询问（或使用EECS 487 ;-）。

### 任务2：服务器端
- 您的第二个任务是编写服务器代码。在命令行上，只需键入imgdb即可运行服务器。服务器没有任何必需的命令行选项。启动时，服务器初始化TCP套接字并从内核获取一个临时端口号，然后将其打印输出到控制台。然后，它等待来自客户端的查询数据包，从与启动该文件夹相同的文件夹/目录中的文件中加载请求的图像，将图像的尺寸发送给客户端，然后将图像传输到客户端。
- 您可以在socks.cpp和 imgdb.cpp中搜索字符串“ Task 2”，以查找必须填写与“ Task 2”相关的代码的位置。首先创建一个TCP套接字，以填充函数socks_servinit（）。然后将套接字与 传递给socks_servinit（）的self参数绑定。此参数必须由调用者设置其sin_addr和sin_port变量。创建并绑定套接字后，侦听连接，并将侦听队列长度设置为宏NETIMG_QLEN。如果提供了sin_port为0时，操作系统将为套接字分配一个随机的临时端口。从套接字获取分配给它的临时端口号，并 使用分配的端口号更新提供的自变量。由于套接字已绑定到INADDR_ANY，因此您无法使用getsockname（）来查找套接字的地址（它将返回0）。相反，要获取当前主机的地址，请先调用gethostname（），然后再调用gethostbyname（）。将gethostname（）返回的FQDN存储在提供的变量“ sname ”中。最后，将套接字描述符返回给调用方。函数socks_servinit（）已被注释，以便应清楚在何处进行哪个套接字API调用。与socks_clntinit（）一样，该函数的重用参数在实验2中使用，您现在可以忽略它。完成此功能大约需要7至13行代码。与Lab 0的server.c没什么不同。
函数socks_accept（sd）接受提供的套接字sd上的连接。设置套接字选项，以使套接字在关闭时会停留NETIMG_LINGER时间，以使映像有时间到达客户端。如果参数 remote不为NULL，则在其中存储连接的客户端的地址和端口号（此功能将在实验2和PA1中使用）。返回接受的连接的套接字描述符。这部分大约需要7至9行代码。

- 函数imgdb :: recvqry（）接收查询数据包，检查该数据包的大小是否正确，预期的版本号和类型（NETIMG_QUERY），以及查询的图像名称是否不超过NETIMG_MAXFNAME。可以在netimg.h中找到查询数据包iqry_t的定义（ 此处显示）以及与上述错误相对应的要发送的错误代码。

查询数据包中包含客户端正在查询的图像的文件名。您可能需要 在编写此函数时参考函数netimg.cpp：netimg_sendqry（）。它大约需要10行代码。

最后，函数imgdb :: sendimsg（td，imsg）将图像规范数据包imsg发送到客户端。此数据包的大部分内容已由imgdb :: marshall_imsg（）（由imgdb :: handleqry（）调用 ）为您填充。但是所有整数字段仍按顺序存在于宿主中。因此，您需要将imsg的所有整数字段转换 为网络字节顺序。您还必须将im_vers字段设置 为NETIMG_VERS。请注意，数据包的 im_type字段已由调用方设置，并且不应在imgdb :: sendimsg（）中进行修改。接下来，函数imgdb :: sendimg（td，image，imgsize，numseg）将图像中包含的图像发送到客户端。在发送图像时，您需要以每NETIMG_USLEEP微秒为单位的慢速发送图像，而不是一次性地发送它，因为这样一来，它就很难观察到了， 总共需要numseg（+1） 块（在函数中计算）（适合您），每个大小 均为segsize。局部变量ip指向图像的开始。完成这两个功能应花费6至8行代码。

- 这就是任务2的全部内容。总共大约需要30-40行代码。如果要使用IDE进行构建，则需要将文件 imgdb.cpp，socks.cpp，netimg.h， socks.h，ltga.h和ltga.cpp添加到项目中（以及wingetopt.h和wingetopt。 c（如果您使用的是Windows）。不要添加netimg.cpp或 netimglut.cpp。这两个任务的总和应不超过70至75行代码。

- 测试您的代码
您可以在Linux，Mac OS X或Windows平台上开发代码。提供的代码已在Linux，Mac OS X和Windows计算机上构建并运行。源代码中包含对Winsock的支持。要在Windows平台上构建代码，您需要将文件wingetopt.h和wingetopt.c添加 到Visual Studio项目中。
测试代码的最简单方法是在本地主机（例如，CAEN实验室中的笔记本电脑或台式机）上同时运行服务器和客户端。例如，如果您正在运行Mac OS X或Linux，并且正在使用Makefile生成程序，请在命令行上运行imgdb。如果您使用的是IDE，请在构建和运行代码之前将命令行选项添加到IDE。（如果您不知道如何执行此操作，请查阅课程说明“ 命令行选项和第三方库”。）如果安全软件提示您是否允许 imgdb访问网络，则只需说“是”。然后运行netimg -s localhost：port＃-q Panda.tga其中localhost应该使用主机名代替，“ port＃”是imgdb报告的端口号 。同样，如果您使用的是IDE，则需要在运行服务器之前在IDE中输入客户端的命令行选项。在自己的计算机上测试代码的优势在于，您可以运行tcpdump或wirehark并查看从程序发送或到达程序的所有数据包，或者视情况而定完全不接收。

- 除了骨骼代码和Makefile文件，我们还提供了可执行的二进制imgdb，称为refimgdb （“参考”的“参考”），即在以下四个CAEN的Linux主机上运行：eecs489p1.engin.umich.edu了至p4。如果将DNS解析器设置为搜索engin.umich.edu 域，则只需输入eecs489p1（最多为p4） 来寻址这四个主机。

- 参考服务器位于课程文件夹 /afs/umich.edu/class/eecs489/w16/lab1/中。它是Red Hat 7的可执行文件，因此不要尝试在Mac OS X，Windows或其他Linux版本（例如Ubuntu）上下载并运行它。要针对提供的参考服务器进行测试，请在CAEN为此课程设置的四台eecs489主机之一上运行该服务器。这四个主机允许UMVPN，MWireless或CAEN Labs网络上的主机连接到其任何端口。如果您在通过UMVPN，MWireless或从任何CAEN Labs访问这些eecs489主机时遇到问题，请立即告知教师。不要在其他任何CAEN主机上运行服务器，例如登录服务器（caen-vnc *），因为尚未设置其安全设置以允许连接到随机端口。除非您正在运行UMVPN，否则您将无法从家庭或办公计算机连接到CAEN eecs489主机。您也将无法从MGUEST无线网络进行连接。不要尝试在ITCS机器上安装客户端，因为它们没有安装OpenGL。

如果在运行netimg客户端时收到以下消息：
libGL error: No matching fbConfigs or visuals found
libGL error: failed to load driver: swrast

如果尽管显示了这些消息，但仍显示图像，则可以忽略它们，或者将shell环境变量LIBGL_ALWAYS_INDIRECT设置为1。

完成任务1后，应立即测试代码。将netimg连接到refimgdb。例如，使用ssh 到eecs489p1.engin.umich.edu，然后运行：

eecs489p1% cd /afs/umich.edu/class/eecs489/w16/lab1
eecs489p1% ./refimgdb

您应该在窗口上看到类似以下内容的内容：

imgdb address is eecs48p1.engin.umich.edu:54539

请注意，将打印出主机名和端口号refimgdb，即 在这种情况下为eecs489p1.engin.umich.edu:54539。然后在本地计算机上打开另一个窗口并运行：

localhost% ./netimg -s eecs489p1.engin.umich.edu:54539 -q Panda.tga

您需要用refimgdb实际为您打印的内容替换eecs489p1.engin.umich.edu:54539。现在应该会弹出一个窗口，并缓慢显示熊猫的灰度图像，从上到下一次显示一个大块。（要看到实际的下载速度没有我们的人工放缓，设置 NETIMG_NUMSEG在1 netimg.h。）根据您的系统中，图像可能会出现倒挂，这是确定（或者你可以在宏设置UPSIDE_DOWN在1 netimglut .cpp）。对于任务2，您必须 使用在本地主机上运行的netimg来测试在其中一台CAEN eecs489主机上 运行的imgdb。

上面是一个非常简单的测试用例，用于检查您的两段代码是否相互通信。您应该使用自己的其他测试用例进一步测试它们。

投稿须知
在本课程中，将公开可用的代码合并到您的解决方案中被认为是作弊行为。与另一种算法一样，放弃一种算法的实现也被认为是作弊行为。例如，如果作业要求您使用堆排序来实现排序，并且您上交了一个使用插入排序代替堆排序的工作程序，它将被视为作弊。如果无法实现所需的算法，则在上交作业时必须通知教学人员。
千万不要使用尚未在提供使用的任何库或编译器选项生成文件。这样做可能会使您的代码不可移植，并且如果我们无法编译您的代码，您将受到重罚。在CAEN eecs489主机上测试您的编译！您提交的内容必须编译和运行 ，而不使用所提供的CAEN eecs489主机错误 的Makefile，未修改。

您的“ Lab1文件 ”包括netimg.cpp， imgdb.cpp，socks.cpp文件。

要上交Lab1，请将Lab1文件的压缩或 压缩的tarball上传到CTools投递箱。保留自己的备份副本！您上传的文件上的时间戳就是您的提交时间。如果超过了截止日期，则您的提交将被视为延迟。只要您遵守截止日期，就可以进行多次“提交”，而没有后期政策的影响。我们强烈建议您使用私人 第三方存储库（例如github或M + Box或Google Drive或Dropbox）来保留提交内容的备份副本。如果本地计算环境发生意外，它不仅可以使您避免丢失文件，还可以在文件上提供第三方时间戳。本地时间戳很容易更改，不能用来确定文件的最后修改时间（-10点）。但是请谨慎使用仅允许私人访问的第三方存储库 。将您的代码放置在可公开访问的第三方存储库中是违反荣誉代码的行为。

仅上交已修改的文件。请勿上交我们提供的尚未修改的支持代码（-4分）。 请勿随您的作业（-4点）一起上交任何二进制文件（对象，可执行文件，dll，库或图像文件）。您的代码必须不需要Makefile中列出的外部库或头文件（-10点）。

不要删除所有printf（）或 cout和cerr，以及为调试目的添加的其他任何日志记录语句。您应该使用调试器进行调试，而不是使用printf（）进行调试。如果我们无法理解您的代码输出，您将得到零分。
